# .vibe 规范 v0.1 —— 开放通用的契约语言

**核心哲学**：**Make Your System READable** — 让意图显性，让 AI 可信。  
**兼容性**：100% 合法 Markdown，**任何 LLM 均可零成本接入**。

---

## 0. 设计原则

1. **Markdown 优先** —— 任何 Markdown 编辑器均可读写；Git 友好，diff 清晰。
2. **符号即契约** —— 行首符号是 AI 的注意力锚点，人类零学习成本，机器可解析。
3. **渐进增强** —— 从一个 `!` 开始，逐步丰富语义，不强制全有或全无。
4. **开放通用** —— 核心符号适配所有模型（GPT-4、Claude、DeepSeek、GLM、本地小模型）；扩展符号优雅降级。
5. **安全内生** —— 安全要求通过 **`!security`** 约束表达，与核心符号风格完全统一。
6. **拒绝过度工程** —— 无阶段模型、无强制缩进、无自动路径解析、无微型 DSL。
7. **一次编写，处处执行** —— 同一份 `.vibe` 文件可被任何 Vibe IDE 消费，行为一致。

---

## 1. 核心哲学：READ 原则

**.vibe 旨在让 AI **正确阅读**系统逻辑。**  
我们将软件契约的四个本质维度映射为 **READ** —— AI 在生成代码前**必须**完成的认知步骤：

| 字母  | 含义     | 符号 | 语义                       | AI 行为约定                                                 |
| ----- | -------- | ---- | -------------------------- | ----------------------------------------------------------- |
| **R** | **规则** | `!`  | 硬性逻辑约束，必须遵守     | 生成校验代码（`if`/`throw`/`assert`）；缺少实现则阻塞交付。 |
| **E** | **效应** | `->` | 状态变更、事件触发、副作用 | 在事务边界内执行；确保原子性。                              |
| **A** | **异常** | `?`  | 边界情况、降级、失败路径   | 生成 `try`/`catch`、降级或重试逻辑。                        |
| **D** | **决策** | `#`  | 架构依据、历史决策         | 转为代码注释保留；AI 不得删除或“优化”这些行。               |

> **.vibe = Make Your System READable.**  
> 任何兼容 .vibe 的 AI **在生成代码前必须 READ 每一个逻辑块** —— 理解规则、效应、异常与决策，并将其完整映射到实现中。

---

## 2. 元信息区（可选）

文件开头可使用 YAML Front‑Matter 记录元数据。**纯文档用途，AI 不强制解析。**

```markdown
---
@vibe: 0.1
@domain: payment
@version: 2.2.0
@owner: pay-team
@scope: service-layer      # 可选：service/domain/infra/presentation
@risk: medium             # 可选：low/medium/high/critical
@deprecated: true         # 可选：模块废弃标记
@deprecation-note: 此模块已由新支付服务替代，请勿新增依赖。
---
```

**推荐字段**：

- `@vibe` – 规范版本（推荐填写）。
- `@domain` – 所属领域。
- `@version` – 需求版本（建议使用语义化版本）。
- `@owner` – 责任人/团队。
- `@scope` – 模块边界，帮助 AI 理解上下文。
- `@risk` – 风险等级；若为 `high`/`critical`，AI **可**在交付前主动输出安全自检清单。
- `@deprecated` / `@deprecation-note` – 废弃标记与迁移提示。

**AI 行为建议（非强制）**：

- 若检测到 `@deprecated: true`，AI **应**避免基于该模块新增功能，并可在生成的代码注释中添加废弃警告。
- 若检测到 `@risk: high/critical`，AI **可**主动输出简要的安全/风险自检说明。

---

## 3. 核心语义符号（强制推荐）

| 符号 | READ | 名称     | 语义                       | AI 行为约定                                 |
| ---- | ---- | -------- | -------------------------- | ------------------------------------------- |
| `!`  | R    | **规则** | 硬性逻辑约束，必须遵守     | 生成校验代码（`if`/`throw`/`assert`）       |
| `->` | E    | **效应** | 状态变更、事件触发、副作用 | 在事务边界内执行；确保原子性                |
| `?`  | A    | **异常** | 边界情况、降级策略         | 生成 `try`/`catch`、降级或重试逻辑          |
| `#`  | D    | **决策** | 架构依据、历史决策         | 转为代码注释保留；AI 不得删除或“优化”这些行 |

**使用方式**：

- 符号**必须**位于行首（可前置 Markdown 列表标记 `-` 或 `*`）。
- **强烈推荐符号后加一个空格**以提升可读性（例如 `- ! 金额必须为正`）。**无空格形式（如 `-!金额`）为向前兼容而支持**；解析器应宽容处理。
- 每行一条语义，简洁明了。
- **建议**单个 `## Logic` 块中的核心符号不超过 **7 条**（7±2 经验法则）。超限时应拆分为子模块或多个 `.vibe` 文件。

**示例**：

```markdown
- ! 支付金额必须 > 0
- -> 扣款成功 -> 更新订单状态为 PAID
- ? 余额不足 -> 返回错误码 40021
- # 使用 Redis 实现分布式限流 @since v1.2
```

---

## 4. 安全约束 —— 统一符号 `!security` 分级

**安全要求是 `!`（规则）的特化**，通过 **`!security`** 表达，并可附加**分级前缀**以触发不同强度的安全实现。

| 分级          | 写法示例                                      | AI 行为要求                                                             |
| ------------- | --------------------------------------------- | ----------------------------------------------------------------------- |
| **critical**  | `!security-critical` 或 `! security-critical` | 最高优先级：强制加密/脱敏、访问控制、审计日志；**缺少实现则阻塞交付**。 |
| **sensitive** | `!security-sensitive`                         | 中等优先级：强制鉴权、限流、输入校验。                                  |
| **aware**     | `!security-aware`                             | 基础优先级：强制日志脱敏、合规存储。                                    |

**示例**：

```markdown
- !security-critical 严禁在日志中记录原始信用卡号（强制加密/脱敏 + 审计追踪）
- !security-sensitive 领取红包需验证用户实名（强制鉴权 + 速率限制）
- !security-aware 记录用户行为日志（必须脱敏并合规存储）
```

### 4.1 安全实现最佳实践（示例性，非强制）

_以下为常见参考实现；AI 可根据项目上下文灵活调整。_

- **`!security-critical`**：
  - 敏感数据静态加密（AES‑256）、传输加密（TLS 1.3）。
  - 强制认证与细粒度授权。
  - 关键操作全链路审计日志。
  - 绝不以明文记录秘密；在日志框架层面统一脱敏。

- **`!security-sensitive`**：
  - 用户身份认证（JWT / Session）。
  - 速率限制（令牌桶/漏桶）。
  - 输入参数合法性校验（类型、范围、格式）。

- **`!security-aware`**：
  - 日志自动脱敏（手机号、身份证、邮箱等）。
  - 个人数据存储符合法规（如 GDPR）。
  - 非必要不采集敏感字段。

---

## 5. 不变量标记 —— `!invariant`（轻量扩展）

**业务不变量**比普通 `!` 规则更强，**必须在所有可能的修改路径上进行断言或校验**。

```markdown
- !invariant 账户余额必须始终 >= 0
- !invariant 订单总价 = 单价 × 数量
```

**AI 行为**：生成全局守卫（数据库触发器、AOP 断言、单元测试），确保不变量永不违反。

---

## 6. 扩展语义符号（推荐实践）

| 符号  | 名称         | 语义                            | AI 行为约定                           | 降级策略                     |
| ----- | ------------ | ------------------------------- | ------------------------------------- | ---------------------------- |
| `^->` | **幂等效应** | 操作必须可安全重试              | 强制幂等键检查（UUID/业务键）+ 防重放 | 视为 `->` 处理               |
| `%`   | **测试意图** | 显式测试场景（Given-When-Then） | 生成完整测试用例骨架，名称自解释      | 忽略（`!` 规则默认隐含测试） |
| `=>`  | **状态机**   | 合法状态转移                    | 生成状态枚举与转换守卫                | 视为普通注释                 |
| `~`   | **软目标**   | 性能或风格目标，不阻塞交付      | 作为优化参考，不强制实现              | 视为普通注释                 |
| `+`   | **增量**     | 本次迭代新增行为                | 仅添加新逻辑，不破坏已有行为          | 视为普通注释                 |

### 6.1 幂等效应最佳实践（示例性，非强制）

- 幂等键可从请求头 `X-Idempotency-Key` 或业务唯一标识（如 `orderId`）获取。
- 幂等状态存储时长**建议 ≥ 24 小时**（可根据业务调整）。
- 重复请求**应**直接返回首次成功结果，不重复执行副作用。

### 6.2 测试意图（`%`）

**所有 `!` 规则均隐含对应的测试要求**，`%` 仅用于**显式补充复杂边界场景**。

```markdown
- % 并发领取：Given 两个请求同时发送，When 执行扣减，Then 只有一个成功
- % 幂等重放：Given 重复的幂等键，When 再次调用相同请求，Then 返回首次结果
```

### 6.3 状态机（`=>`）

```markdown
- => CREATED -> PAID
- => PAID -> REFUNDING
- => REFUNDING -> REFUNDED
```

---

## 7. 契约与类型（结构化自然语言）

**保持人类可写、AI 可读的极简风格，仅增强关键元信息。**

### 7.1 接口契约

```markdown
## Contract

**POST /api/pay**

- In: { userId, orderId, amount }
- Out(200): { txId, status }
- Error(400): INVALID_PARAMS
- Error(429): RATE_LIMITED
- Auth: JWT Bearer Token (scope: pay.create) # 认证方式说明
- Idempotency: required (X-Idempotency-Key)
- Transaction: 本地数据库事务
```

### 7.2 类型描述（完全自由）

**用纯自然语言描述类型即可，无需任何结构化语法。**  
若希望更简洁，可使用简单标记风格——**但绝不强制**。

```markdown
## Types

- `Amount`：定点数，2 位小数，最小值 0.01，最大值 1,000,000。
- `Status`：枚举 [PENDING, SUCCESS, FAILED]。
- `UserId`：字符串，长度 16–32，字母数字组合。
```

**AI 行为**：根据描述推断数据类型和约束，生成对应的强类型定义与校验逻辑。

### 7.3 非功能性需求（NFR）显式位置

```markdown
## NFR (QoS)

- ~ 响应时间 < 200ms (p99)
- ! 并发支持 ≥ 1000 QPS
- SLA: 99.95% 可用性
```

---

## 8. 密度与模块化

**防止 AI 注意力分散的推荐实践：**

- **7 符号经验法则**：单个 `## Logic` 块中的核心符号（`! -> ? #`）最好不超过 **7 条**。超过此数应考虑模块化。
- **原子拆分**：将复杂功能拆分为多个 `.vibe` 文件，并通过显式引用关联。
- **显式引用**：用自然语言清晰指明依赖，例如：
  ```markdown
  - -> 执行结算逻辑（参见 `checkout-core.vibe@0.3#Contract`）
  - # 依赖用户服务的角色校验（位于 `../../user/auth.vibe`）
  ```

**AI 行为**：若检测到引用但上下文中未提供被引文件，AI **应**主动提示用户补充。

---

## 9. 版本与演进标记（轻量）

在决策行或元信息中可附加 **`@since` / `@deprecated` / `@evolving`**，帮助 AI 理解历史与计划变更。

```markdown
- # 使用 Redis Lua 脚本保证原子扣减 @since v1.0 @evolving（计划迁移到 DynamoDB）

---

@deprecated: true
@deprecation-note: 此模块已由新支付服务替代，请勿新增依赖。

---
```

**AI 行为建议（非强制）**：

- `@since` 提供版本背景。
- `@evolving` 表示该决策未来可能变更；AI **应**避免过度固化。
- `@deprecated`：AI **应**优先使用替代方案，并可在生成的代码注释中提示废弃状态。

---

## 10. AI 执行协议（轻量版）

**当消费 `.vibe` 文件时，AI 应隐含遵循以下 READ 步骤（无需强制输出，但需内化）：**

1. **扫描** —— 识别所有 `!`、`->`、`?`、`#` 及扩展符号。
2. **映射** —— 确保每条 `!` 规则在代码中都有对应的校验语句。
3. **安全优先** —— `!security-*` 约束必须按相应级别实现；在注释或日志中体现。
4. **测试生成** —— 为每条 `!` 规则生成至少一个单元测试；对 `%` 生成完整的 Given‑When‑Then 测试骨架。
5. **决策保留** —— 将所有 `#` 行转为代码注释；**不得删除**。

**AI → 人类澄清（推荐）**：  
当需求模糊时，AI **应**主动提问澄清，而非猜测。**无固定格式要求**；问题应自然清晰，例如：

> “这个 `!` 规则是否允许管理员豁免？”  
> “当 `?` 余额不足和 `?` 账户锁定同时发生时，应优先返回哪个错误？”  
> “`#` 决策中提到了 Redis，现在还在用吗？”

---

## 11. 完整示例（v0.1 风格）

```markdown
---
@vibe: 0.1
@domain: marketing
@module: red-packet-claim
@scope: service-layer
@risk: medium
---

# 红包领取服务

## Contract

**POST /api/v2/red-packet/claim**

- In: { packetId, userId }
- Out(200): { amount, currency }
- Auth: JWT (scope: user.claim)，需校验用户 ID 与 token 一致
- Idempotency: required (X-Idempotency-Key)

## Types

- `Amount`：定点数，2 位小数，最小值 0.01。
- `Currency`：枚举 [CNY, USD]。

## NFR

- ~ 响应时间 < 100ms (p95)
- ! 并发支持 ≥ 500 QPS
- SLA: 99.95% 可用性

---

## Logic

- ! 账户状态必须为 ACTIVE
- ! 领取频率限制：每分钟每用户 1 次
- !security-sensitive 领取需验证用户实名（强制鉴权 + 审计日志）
- -> 校验通过 -> 扣减红包余额（Redis Lua）
- -> 记录领取明细到 claim_history
- ^-> 增加用户钱包余额（必须使用幂等键，防重放）
- ? 余额不足 -> 返回 EMPTY_PACKET
- ? 并发冲突 -> 自动重试最多 3 次
- !invariant 红包余额必须始终 >= 0

## Decision

- # 使用 Redis Lua 脚本保证原子扣减 @architectA @since v1.0

## Testing

- % 并发测试：Given 10 个并发请求，When 执行扣减，Then 只有库存数量对应的请求成功
- % 幂等重放：Given 重复的幂等键，When 再次调用相同请求，Then 返回首次结果

## Security & Compliance

- !security-critical 严禁记录完整信用卡号
- !security-aware 前端日志中的用户 ID 需脱敏
```

---

## 12. 兼容性与版本演进

| 版本     | 核心符号       | 扩展符号                      | 安全表达             | 定位                                                |
| -------- | -------------- | ----------------------------- | -------------------- | --------------------------------------------------- |
| **v0.1** | **`! -> ? #`** | **`^-> % => ~ + !invariant`** | **`!security` 分级** | **首个正式发布：开放通用，READ 哲学，密度与模块化** |

**核心承诺**：

- 四个核心符号 **`!` `->` `?` `#`** 的语义**永不改变，永不废弃**。
- 所有扩展符号均为**可选**，永不成为强制要求。
- **未来所有版本必须保持向前兼容** —— 为 v0.1 编写的 `.vibe` 文件在后续版本中依然完全有效。

---

## 13. 开源与贡献

**.vibe 并非私有标准，而是属于整个 Vibe Coding 社区的公共协议。**

- **规范仓库**：`https://github.com/vibe-spec/spec`（采用 **CC BY 4.0** 许可）
- **贡献方式**：提交 Issue / Pull Request，或分享使用案例。
- **生态项目**：鼓励开发 Linter、语法高亮插件、适配器等工具，但**绝不强制任何工具依赖**。

---

**Make Your System READable.**  
—— .vibe v0.1
