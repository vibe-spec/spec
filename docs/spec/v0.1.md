# .vibe Specification v0.1 —— An Open, General-Purpose Contract Language

**Core Philosophy**: **Make Your System READable** — Make intent explicit, make AI trustworthy.  
**Compatibility**: 100% valid Markdown, **zero‑cost adoption for any LLM**.

---

## 0. Design Principles

1. **Markdown First** – Readable and writable in any Markdown editor; Git‑friendly, clean diffs.
2. **Symbols as Contracts** – Line‑leading symbols are attention anchors for AI, zero learning cost for humans, machine‑parseable.
3. **Progressive Enhancement** – Start with a single `!` and enrich semantics gradually; no all‑or‑nothing requirement.
4. **Open & Universal** – Core symbols work with all models (GPT‑4, Claude, DeepSeek, GLM, local small models); extension symbols degrade gracefully.
5. **Security by Design** – Security requirements are expressed via **`!security`** constraints, consistent with the core symbol style.
6. **No Over‑engineering** – No phase models, no forced indentation, no automatic path resolution, no mini‑DSLs.
7. **Write Once, Execute Everywhere** – The same `.vibe` file can be consumed by any Vibe IDE with consistent behavior.

---

## 1. Core Philosophy: The READ Principle

.vibe is built to make AI **READ** system logic correctly.  
We map the four essential dimensions of software contracts to **READ** — the cognitive steps an AI **must** take before generating code:

| Letter | Meaning      | Symbol | Semantics                                    | AI Behavior Contract                                                                      |
| ------ | ------------ | ------ | -------------------------------------------- | ----------------------------------------------------------------------------------------- |
| **R**  | **Rule**     | `!`    | Hard logical constraint, must be enforced    | Generate validation code (`if`/`throw`/`assert`); missing implementation blocks delivery. |
| **E**  | **Effect**   | `->`   | State change, event trigger, side effect     | Execute inside a transaction boundary; ensure atomicity.                                  |
| **A**  | **Anomaly**  | `?`    | Edge case, degradation, failure path         | Generate `try`/`catch`, fallback, or retry logic.                                         |
| **D**  | **Decision** | `#`    | Architectural rationale, historical decision | Preserve as code comments; AI must not remove or “optimise” these lines.                  |

> **.vibe = Make Your System READable.**  
> Any .vibe‑compatible AI **must READ every logical block** before generating code — understand the Rules, Effects, Anomalies, and Decisions, and map them completely into the implementation.

---

## 2. Metadata Section (Optional)

YAML Front‑Matter can be used at the beginning of a file to record metadata. **For documentation purposes only; AI is not required to parse it.**

```markdown
---
@vibe: 0.1
@domain: payment
@version: 2.2.0
@owner: pay-team
@scope: service-layer      # optional: service/domain/infra/presentation
@risk: medium             # optional: low/medium/high/critical
@deprecated: true         # optional: module deprecation flag
@deprecation-note: This module is superseded by the new payment service. Please do not add new dependencies.
---
```

**Recommended fields**:

- `@vibe` – Specification version (recommended).
- `@domain` – Problem domain.
- `@version` – Requirement version (semantic versioning encouraged).
- `@owner` – Responsible person or team.
- `@scope` – Module boundary, helps AI understand context.
- `@risk` – Risk level; for `high`/`critical` the AI **may** output a security self‑check before delivery.
- `@deprecated` / `@deprecation-note` – Deprecation marker and migration hint.

**AI behaviour suggestions (non‑mandatory)**:

- If `@deprecated: true` is detected, the AI **should** avoid adding new functionality based on this module and may add a deprecation warning comment in the generated code.
- If `@risk: high/critical` is detected, the AI **may** proactively output a brief security/risk self‑check.

---

## 3. Core Semantic Symbols (Mandatory Recommendation)

| Symbol | READ | Name         | Semantics                                    | AI Behaviour Contract                                                   |
| ------ | ---- | ------------ | -------------------------------------------- | ----------------------------------------------------------------------- |
| `!`    | R    | **Rule**     | Hard logical constraint, must be obeyed      | Generate validation code (`if`/`throw`/`assert`)                        |
| `->`   | E    | **Effect**   | State change, event trigger, side effect     | Execute within a transaction boundary; ensure atomicity                 |
| `?`    | A    | **Anomaly**  | Edge case, fallback strategy                 | Generate `try`/`catch`, fallback, or retry logic                        |
| `#`    | D    | **Decision** | Architectural rationale, historical decision | Preserve as code comments; AI must not delete or “optimise” these lines |

**Usage**:

- Symbols **must** be placed at the beginning of a line (may be preceded by a Markdown list marker `-` or `*`).
- **A space after the symbol is strongly recommended** for readability (e.g. `- ! Amount must be positive`). **Space‑less forms (e.g. `-!Amount`) are supported for backward compatibility**; parsers should handle both.
- One semantic statement per line, concise.
- It is **recommended** to keep the number of core symbols in a single `## Logic` block under **7** (the 7±2 heuristic). Split into sub‑modules or multiple `.vibe` files when exceeding this limit.

**Example**:

```markdown
- ! Payment amount must be > 0
- -> Deduction succeeds -> update order status to PAID
- ? Insufficient balance -> return error code 40021
- # Using Redis for distributed rate limiting @since v1.2
```

---

## 4. Security Constraints — Unified `!security` with Severity Levels

**Security requirements are a specialization of `!` (Rule)** and are expressed using **`!security`** with an optional **severity prefix** that triggers different implementation rigour.

| Severity      | Example Syntax                                | AI Behaviour Requirements                                                                                         |
| ------------- | --------------------------------------------- | ----------------------------------------------------------------------------------------------------------------- |
| **critical**  | `!security-critical` or `! security-critical` | Highest priority: enforce encryption, data masking, access control, audit logging; **block delivery if missing**. |
| **sensitive** | `!security-sensitive`                         | Medium priority: enforce authentication, rate limiting, input validation.                                         |
| **aware**     | `!security-aware`                             | Basic priority: enforce logging masking, compliance storage.                                                      |

**Examples**:

```markdown
- !security-critical Never log raw credit card numbers (mandatory encryption/masking + audit trail)
- !security-sensitive Claiming requires user real‑name verification (mandatory auth + rate limiting)
- !security-aware Record user behaviour logs (must be masked and stored in compliance)
```

### 4.1 Security Implementation Best Practices (Illustrative, Non‑mandatory)

_These are common reference implementations; AI may adapt them to the project context._

- **`!security-critical`**:
  - Encrypt sensitive data at rest (AES‑256) and in transit (TLS 1.3).
  - Mandatory authentication and fine‑grained authorization.
  - Full audit trail for critical operations.
  - Never log plaintext secrets; apply masking at the logging framework level.

- **`!security-sensitive`**:
  - Authenticate user identity (JWT / Session).
  - Apply rate limiting (token bucket / leaky bucket).
  - Validate input parameters (type, range, format).

- **`!security-aware`**:
  - Automatically mask sensitive fields (phone number, ID card, email) in logs.
  - Store personal data in compliance with regulations (e.g. GDPR).
  - Avoid collecting sensitive fields unless strictly necessary.

---

## 5. Invariant Marker — `!invariant` (Lightweight Extension)

**Business invariants** are stronger than ordinary `!` rules. They **must** be asserted or validated **on every possible modification path**.

```markdown
- !invariant Account balance MUST always be >= 0
- !invariant Order total = unit price × quantity
```

**AI Behaviour**: Generate global guards (database triggers, AOP assertions, unit tests) that ensure the invariant is never violated.

---

## 6. Extended Semantic Symbols (Recommended Practice)

| Symbol | Name                  | Semantics                                 | AI Behaviour Contract                                                   | Degradation Strategy                      |
| ------ | --------------------- | ----------------------------------------- | ----------------------------------------------------------------------- | ----------------------------------------- |
| `^->`  | **Idempotent Effect** | Operation must be safely repeatable       | Enforce idempotency key check (UUID / business key) + replay prevention | Treated as `->`                           |
| `%`    | **Test Intent**       | Explicit test scenario (Given‑When‑Then)  | Generate full test case skeleton with self‑explaining name              | Ignored (tests are implied for every `!`) |
| `=>`   | **State Machine**     | Legal state transition                    | Generate state enum and transition guards                               | Treated as plain comment                  |
| `~`    | **Soft Goal**         | Performance or style target, non‑blocking | Use as optimisation reference; not mandatory                            | Treated as plain comment                  |
| `+`    | **Delta**             | New behaviour in this iteration           | Add new logic only; do not break existing behaviour                     | Treated as plain comment                  |

### 6.1 Idempotent Effect Best Practices (Illustrative, Non‑mandatory)

- The idempotency key can be taken from the `X-Idempotency-Key` header or a business unique identifier (e.g. `orderId`).
- Idempotency state storage duration is **recommended ≥ 24 hours** (may be adjusted per business needs).
- Duplicate requests **should** return the first successful result without re‑executing the side effect.

### 6.2 Test Intent (`%`)

**All `!` rules implicitly imply corresponding test requirements.** `%` is only for **explicitly supplementing complex edge cases**.

```markdown
- % Concurrent claim: Given two requests sent simultaneously, When the deduction is performed, Then only one succeeds
- % Idempotent replay: Given a duplicate idempotency key, When the same request is sent again, Then the first result is returned
```

### 6.3 State Machine (`=>`)

```markdown
- => CREATED -> PAID
- => PAID -> REFUNDING
- => REFUNDING -> REFUNDED
```

---

## 7. Contracts & Types (Structured Natural Language)

**Keep it human‑writable and AI‑readable; only enhance essential metadata.**

### 7.1 Interface Contract

```markdown
## Contract

**POST /api/pay**

- In: { userId, orderId, amount }
- Out(200): { txId, status }
- Error(400): INVALID_PARAMS
- Error(429): RATE_LIMITED
- Auth: JWT Bearer Token (scope: pay.create) # authentication description
- Idempotency: required (X-Idempotency-Key)
- Transaction: local database transaction
```

### 7.2 Type Descriptions (Completely Free)

**Describe types in plain natural language. No structured syntax is required.**  
If you prefer a more concise style, you may use simple notation – **but this is never mandatory**.

```markdown
## Types

- `Amount`: fixed‑point number with 2 decimal places, min 0.01, max 1,000,000.
- `Status`: enum [PENDING, SUCCESS, FAILED].
- `UserId`: string, length 16–32, alphanumeric.
```

**AI Behaviour**: Infer data types and constraints from the description, and generate corresponding strongly‑typed definitions and validation logic.

### 7.3 Non‑Functional Requirements (NFR) – Explicit Section

```markdown
## NFR (QoS)

- ~ Response time < 200ms (p99)
- ! Concurrency ≥ 1000 QPS
- SLA: 99.95% uptime
```

---

## 8. Density & Modularisation

**Recommended practices to prevent AI attention dilution:**

- **7‑symbol heuristic**: A single `## Logic` block should ideally contain **no more than 7 core symbols** (`! -> ? #`). Exceeding this indicates the need for modularisation.
- **Atomic decomposition**: Split complex functionality into multiple `.vibe` files and link them via explicit references.
- **Explicit references**: Use natural language to clearly point to dependencies, e.g.:
  ```
  - -> Perform settlement logic (see `checkout-core.vibe@0.3#Contract`)
  - # Depends on user service role validation (located in `../../user/auth.vibe`)
  ```

**AI Behaviour**: If a reference is detected but the referenced file is not available in the context, the AI **should** actively ask the user to provide it.

---

## 9. Versioning & Evolution Markers (Lightweight)

In decision lines or metadata, you may attach **`@since` / `@deprecated` / `@evolving`** to help AI understand history and planned changes.

```markdown
- # Using Redis Lua script for atomic deduction @since v1.0 @evolving (plan to migrate to DynamoDB)

---

@deprecated: true
@deprecation-note: This module is superseded by the new payment service. Please do not add new dependencies.

---
```

**AI Behaviour Suggestions (Non‑mandatory)**:

- `@since` provides version context.
- `@evolving` signals that the decision may change in the future; the AI **should** avoid over‑committing to it.
- `@deprecated`: the AI **should** prefer the alternative solution and may add a deprecation comment in the generated code.

---

## 10. AI Execution Protocol (Lightweight)

**When consuming a `.vibe` file, an AI should implicitly follow these READ steps (no mandatory output, but internalised):**

1. **Scan** – Identify all `!`, `->`, `?`, `#`, and extension symbols.
2. **Map** – Ensure every `!` rule has a corresponding validation statement in the code.
3. **Security first** – `!security-*` constraints must be implemented with the appropriate severity; reflect this in comments or logs.
4. **Test generation** – Generate at least one unit test for each `!` rule; for `%`, generate a full Given‑When‑Then test skeleton.
5. **Decision retention** – Convert all `#` lines into code comments; **do not delete**.

**AI → Human Clarification (Recommended)**:  
When requirements are ambiguous, the AI **should** proactively ask for clarification rather than guessing. **No fixed format is required**; questions should be natural and clear, for example:

> “Does this `!` rule allow any exemptions for administrators?”  
> “When both `?` insufficient balance and `?` account locked occur simultaneously, which error should take precedence?”  
> “The `#` Decision mentions Redis – is this still in use?”

---

## 11. Complete Example (v0.1 Style)

```markdown
---
@vibe: 0.1
@domain: marketing
@module: red-packet-claim
@scope: service-layer
@risk: medium
---

# Red Packet Claim Service

## Contract

**POST /api/v2/red-packet/claim**

- In: { packetId, userId }
- Out(200): { amount, currency }
- Auth: JWT (scope: user.claim), must validate that user ID matches token
- Idempotency: required (X-Idempotency-Key)

## Types

- `Amount`: fixed‑point number with 2 decimal places, min 0.01.
- `Currency`: enum [CNY, USD].

## NFR

- ~ Response time < 100ms (p95)
- ! Concurrency ≥ 500 QPS
- SLA: 99.95% uptime

---

## Logic

- ! Account status must be ACTIVE
- ! Claim rate limit: 1 per minute per user
- !security-sensitive Claiming requires user real‑name verification (mandatory auth + audit log)
- -> Validation succeeds -> deduct red packet balance (Redis Lua)
- -> Record claim detail in claim_history
- ^-> Increase user wallet balance (must use idempotency key, replay protection)
- ? Insufficient balance -> return EMPTY_PACKET
- ? Concurrency conflict -> retry automatically up to 3 times
- !invariant Red packet balance MUST always be >= 0

## Decision

- # Use Redis Lua script to ensure atomic deduction @architectA @since v1.0

## Testing

- % Concurrency test: Given 10 concurrent requests, When deduction is performed, Then only the available stock amount succeeds
- % Idempotent replay: Given a duplicate idempotency key, When the same request is sent again, Then the first result is returned

## Security & Compliance

- !security-critical Never log full credit card numbers
- !security-aware Mask user ID in front‑end logs
```

---

## 12. Compatibility & Versioning

| Version  | Core Symbols   | Extension Symbols             | Security Expression         | Positioning                                                                            |
| -------- | -------------- | ----------------------------- | --------------------------- | -------------------------------------------------------------------------------------- |
| **v0.1** | **`! -> ? #`** | **`^-> % => ~ + !invariant`** | **`!security` with levels** | **First official release: open, universal, READ philosophy, density & modularisation** |

**Core Commitment**:

- The semantics of the four core symbols **`!` `->` `?` `#`** will **never change** and **never be deprecated**.
- All extension symbols are **optional** and will never become mandatory.
- **All future versions must remain forward‑compatible** – a `.vibe` file written for v0.1 must be valid in all later versions.

---

## 13. Open Source & Contribution

**.vibe is not a proprietary standard — it is a public protocol owned by the entire Vibe Coding community.**

- **Specification Repository**: `https://github.com/vibe-spec/spec` (licensed under **CC BY 4.0**)
- **How to Contribute**: Submit an Issue / Pull Request, or share your use cases.
- **Ecosystem Projects**: Linters, syntax highlighters, adapters, and other tools are encouraged – **but no tooling is ever mandatory**.

---

**Make Your System READable.**  
—— .vibe v0.1
